# 面向对象
## 构造顺序

先调用基类的构造函数，在调用子类的构造函数。

一个类可以知道自己是从哪个基类继承过来的，但不知道哪些类继承了它。在构造函数内，可能需要访问基类的成员，因此必须要求基类已经构造完毕。

析构函数调用顺序和构造函数相反。因为在析构函数中可能要访问基类成员，必须要求基类还没被析构。

## 虚析构函数

构造函数不能为虚函数，但是析构函数常常必须是虚函数。

在向上类型转换时，指针指向基类地址，在delete期间，编译器只能知道这个析构函数的基类版本，因此，需要使用虚函数来解决这个问题，使编译器能正确调用子类版本的析构函数。如果不使用虚析构函数，可能导致子类的成员变量没有被delete，导致内存泄漏。

## 虚函数

使用virtual来实现虚函数。在进行向上类型转换时，早捆绑机制只保留基类的接口，使用virtual告诉编译器使用晚捆绑机制，在向上类型转换时能保留子类的接口。

在声明了虚函数的类中，编译器自动在类中声明了指向虚函数表的指针。如果有一个或多个虚函数，都只需要一个VPTR，因为VPTR指向虚函数表，而所有的虚函数都存放在一个表中。

## 纯虚函数

纯虚函数是为了使基类成为抽象基类，即只希望使用基类的接口，而不希望创建基类的对象。定义纯虚函数，需要使用virtual，并在声明的函数明后面加上= 0。例如：virtual void func（） = 0。


## 组合\继承
## 多重继承
## 构造函数\析构函数中的异常处理


